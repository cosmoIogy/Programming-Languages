Lecture 1-1: Intro to ML

ML is a functional programming language, i.e., it evaluates expressions.

* every expression you put into the ML interpreter must end in a semicolon

the first response from the code 
    - 3+4;
is:
    val it = 7 : int

lets analyze:

val means value
it
    variable in the ML environment that contains the last expression evaluated 

:
    the ML symbol that associates values to types

int
    integer, the value type 

* ML is a strongly typed language, i.e., every expression in ML has a type 

BASIC/PRIMITIVE TYPES OF ML 

int
  the integer type. they are constructed by sequences of digits. you may start with ~ for negative values

real
  float/real decimal values. they are constructed by: 
   1) starts with optional ~
   2) a sequence of one or more digits
   3) (a) a decimal point and one or more digits
        (b) the letter E or e, an optional ~, and one or more digit

bool
   the boolean type. there are only two values: true, false

string
   they are constructed by surrounding characters with double quotes

char
   the character type. they are constructed by #"<character>"

unit
   there is only one value of this type: () 

--

Continue Lecture 1-1

INTEGER OPERATORS
+, -, *, div, mod

REAL OPERATORS 
+, -, *, /

STRING OPERATOR 
^

NOTE: ML ignores whitespace and the up arrow retypes previous lines

COMPARISON OPERATORS 
=, <, >, <=, >=, <>

NOTE: These are overloaded on ints and real, except you cannot use = and <> on reals 

LOGICAL OPERATORS 

andalso, orelse, not 

NOTE: You can add parantheses with operators to force precedence, ex: (2+3)*5
Unitary operators have precedence over binary operators, generally. 

There are built in library functions for converting types (not casting)

COERCION FUNCTIONS 
ord: char -> int 
chr: int -> char 
real: int -> real
str: char -> string

IF-THEN-ELSE OPERATOR 
The form of the operator is:
    if <bool expression> then <expr1:T> else <expr2:T>
When the bool evaluates to true, the this expression exaluates to exp1, otherwise to exp2. both expressions must
be of the same type

Lecture 1-2: ML Variables, types, and Data Structures (List)

IDENITFIERS/VARIABLES IN ML 
Variables in ML are constructed by:
    1. Starts with an uppercase letter, lowercase letter, or '
    2. Followed by zero or more characters from step 1 including _
NOTE: We dont usually use ', ML will do this for a later concept 

VALUE DECLERATIONS
The code form to bind a value to a variable is:
    val <identifier> = <value>

TUPLES 
Tuples are constructed by:
    1. Start with (
    2. Sequence of values separted by ,
    3. End with ) 

NOTE: This is our first example of a non-primitive type. If the components of a tuple are of type T1, T2, ..., Tn,
then the type of the tuple is T1 * T2 * ... * Tn 

TUPLE OPERATOR 
#<digit><tuple>
    Returns the component in the tuple corresponding to the digit starting at 1

LISTS
Lists are constructed by:
    1. Starts with [
    2. Sequence of values of the SAME TYPE, seperated by commas 
    3. Ends with ]
If the values in a list are of Type T, then the list itself is of type T list (non-primitive)

The symbols: 'a, 'b, 'c, etc., are used by ML as placeholder types. They are pronounced as alpha, beta, gamma, etc

NOTE: List has higher precedence than *

LIST OPERATORS

hd <list>
    returns the first element of the list 

tl <list> 
    returns all but the head of the list (as a list)

<list1:T list>@<list2:T list>
    concantenates two list together 

NOTE: at the end of every ML list is an empty list

<value:T> :: <list: T list>
    "cons" operator appends a value to a list. it is right-associative 

NOTE: the synonym for [] is nil 

BUILT-IN LIST FUNCTIONS 

explode : string -> char list 
implode : char list -> string 
concat : string list -> string 

ML FILES 

to create a file that is reeadable by the ML interpreter, end it with the .sml extension or .ml extension 
then the built-in function to load a file into the ML interpreter is
    use : string -> unit 
where the input is the name of the file as a string. note that the contents are added to the ML stack environment.
comments in an ML file are surrounded b (* *)

Lecture 1-3: ML Function

the syntax to create a function in ML is 
    fun <identifier> <paramater(s):T1> = <expression:T2>
the name/type of this function will be 
    <identifier> : T1 -> T2 

Ex. write a function that inputs an integer and returns that integer plus 1.

    fun plusone x = x + 1;

Ex. write a function that inputs an integer and returns its square 

    fun square x = x*x;

Ex. write a function that inputs a real and returns its square 

    fun squarereal x:real = x*x

Ex. (In-Class) Write a function with name/type toUpper : char -> char 
    that inputs a lowercase character and returns its uppercase version (no error checking)

    fun toUpper x = chr(ord(x) - 32);

Ex. (In-Class) Write a function with name/type max3 : int * int * int -> int 
    that returns the maximum of three input integers. use the if-then-else operator only. 

    -fun max3(3, 9, 6);
    val it = 9 : int 

    fun max3 (a,b,c) = 
        if a>b then
            if a>c then a else c
        else
            if b>c then b else c;

In ML, global variables are frowned upon

val y = 4;
fun myfun a = y+a;
val y = 20;
myfun(3);
returns 7 because my fun is binded to the first value 

another way to construct a function is by declaring an anonymous functions/functions
defined on the fly/functions without a name. the syntax is:

    fn <parameter(s)> => expression;

    val addfour = fn x => x+4;

ex: write a function named apply that takes a function and value, then returns
that input function applied to the value 

fun apply (f, a) = f(a);
returns: val apply = fn : ('a -> 'b) * a' -> b'

ex: write a function called getFun that inputs an integer a and then returns the
function f(x) = a*x; 

fun getFun a = (fn x => a*x);
returns: val getFun = fn : int -> int -> int
                           input    output type
                           type 

ex. (in-class) write a function named past that inputs a string and then 
concantenates "ed" on the end. for example, 
    - past("suck");
    val it = "sucked" : string

fun past x = x ^ "ed";

ex. (in-class) write a function named jeremy : char -> string -> string 
that inputs a character c and then returns
the string function f(w) = wc (concantenates the character to the end of the string)
and test it. for example, 
    - val myfun = jeremy(#"z");
    val my fun = fn : string -> string
    - myfun("lor");
    val it = "lorz" : string

fun jeremy c = fn s => s^(str c);

Lecture 1-4: Recursion 

Loops are frowned upon! Thats a procedural style, not functional! 

Ex. Write our own length function named mylength. First, we do it badly:

fun mylength L = if L=[] then 0 else 1+mylength(tl(L));

NOTE: ''a means that you can only use equality types

A better way to define functions on lists in ML is to use pattern matching:

fun <identifier> <pattern1> = <exp1>
    <identifier> <pattern2> = <exp2>
    ..
    <identifier> <pattern-n> = <expn>

Allowed patterns are constants/literals or expressions with ::

fun mylength2 [] = 0
    | mylength2 (x::xs) = 1+mylength2(xs); 

This wildcard symbol in ML is _. It is used in place of a variable when it is not needed. The 
last example can be written more efficiently as:

fun mylength3 [] = 0
    | mylength3 (_::xs) = 1+mylength3(xs);

New construct: case 
Plays the role of "switch" from other language, but it is just another format to do
pattern matching. The syntax is

    case <expression> of <match> 

Then <match> will have the form 

    <patern1> => <exp1> | <pattern2> =>
    <exp2> | ... | <pattern-n> => <expn>

We can also write the last example as:

fun mylength4 L = case L of [] => 0 | (x::xs) => 1+mylength4(xs); 

Ex. write the factoiral function using recursion and pattern matching 

fun steve 0 = 1
    | steve n = n*steve(n-1);

Ex. write a function named listsum that inputs a list of integers and returns their sum. for example:
    - listsum [2,3,5,7];
    val it = 17 : int 

fun listsum [] = 0
    | listsum (x::xs) = x+sum(xs); 

Ex. Write a recursive function with pattern matching named pairlistsum that inputs an int * int list
and returns the sum of all values. For example,
    - pairlistsum [(2,3),(5,7)];
        val it = 17 : int 

fun pairlistsum [] = 0;
    | pairlistsum ((x,y)::xs) = x+y+pairlistsum(xs);

New Reserved Word: and 
Allows you to do more than one decleration at the same time 

Ex. Write mutually recursive functions with pattern matching named isOdd and isEven that inputs a 
non-neg integer and returns the correct bool value. For example,
    - isEven(4);
    val it = true : bool
    - isodd(4);
    val it = false : bool 

fun isEven 0 = true | isEven n = isOdd(n-1) and isOdd 0 = false | isOdd n = isEven(n-1);

Ex. Write a recursive ML function with pattern matching named linSearch that inputs a 2-tuple:
an int list and int. It will return the index position if the value is found. Assuming the indices
start at 1. If the value is not found, it should return -1 but instead, we will return list size plus 1
for now.

fun linSearch ([],_) = 1
    | linSearch (x::xs, n) = if x = n then 1 else 1+linSearch(xs,n);