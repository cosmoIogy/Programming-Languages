Lecture 1-1: Intro to ML

ML is a functional programming language, i.e., it evaluates expressions.

* every expression you put into the ML interpreter must end in a semicolon

the first response from the code 
    - 3+4;
is:
    val it = 7 : int

lets analyze:

val means value
it
    variable in the ML environment that contains the last expression evaluated 

:
    the ML symbol that associates values to types

int
    integer, the value type 

* ML is a strongly typed language, i.e., every expression in ML has a type 

BASIC/PRIMITIVE TYPES OF ML 

int
  the integer type. they are constructed by sequences of digits. you may start with ~ for negative values

real
  float/real decimal values. they are constructed by: 
   1) starts with optional ~
   2) a sequence of one or more digits
   3) (a) a decimal point and one or more digits
        (b) the letter E or e, an optional ~, and one or more digit

bool
   the boolean type. there are only two values: true, false

string
   they are constructed by surrounding characters with double quotes

char
   the character type. they are constructed by #"<character>"

unit
   there is only one value of this type: () 

--

Continue Lecture 1-1

INTEGER OPERATORS
+, -, *, div, mod

REAL OPERATORS 
+, -, *, /

STRING OPERATOR 
^

NOTE: ML ignores whitespace and the up arrow retypes previous lines

COMPARISON OPERATORS 
=, <, >, <=, >=, <>

NOTE: These are overloaded on ints and real, except you cannot use = and <> on reals 

LOGICAL OPERATORS 

andalso, orelse, not 

NOTE: You can add parantheses with operators to force precedence, ex: (2+3)*5
Unitary operators have precedence over binary operators, generally. 

There are built in library functions for converting types (not casting)

COERCION FUNCTIONS 
ord: char -> int 
chr: int -> char 
real: int -> real
str: char -> string

IF-THEN-ELSE OPERATOR 
The form of the operator is:
    if <bool expression> then <expr1:T> else <expr2:T>
When the bool evaluates to true, the this expression exaluates to exp1, otherwise to exp2. both expressions must
be of the same type

Lecture 1-2: ML Variables, types, and Data Structures (List)

IDENITFIERS/VARIABLES IN ML 
Variables in ML are constructed by:
    1. Starts with an uppercase letter, lowercase letter, or '
    2. Followed by zero or more characters from step 1 including _
NOTE: We dont usually use ', ML will do this for a later concept 

VALUE DECLERATIONS
The code form to bind a value to a variable is:
    val <identifier> = <value>

TUPLES 
Tuples are constructed by:
    1. Start with (
    2. Sequence of values separted by ,
    3. End with ) 

NOTE: This is our first example of a non-primitive type. If the components of a tuple are of type T1, T2, ..., Tn,
then the type of the tuple is T1 * T2 * ... * Tn 

TUPLE OPERATOR 
#<digit><tuple>
    Returns the component in the tuple corresponding to the digit starting at 1

LISTS
Lists are constructed by:
    1. Starts with [
    2. Sequence of values of the SAME TYPE, seperated by commas 
    3. Ends with ]
If the values in a list are of Type T, then the list itself is of type T list (non-primitive)

The symbols: 'a, 'b, 'c, etc., are used by ML as placeholder types. They are pronounced as alpha, beta, gamma, etc

NOTE: List has higher precedence than *

LIST OPERATORS

hd <list>
    returns the first element of the list 

tl <list> 
    returns all but the head of the list (as a list)

<list1:T list>@<list2:T list>
    concantenates two list together 

NOTE: at the end of every ML list is an empty list

<value:T> :: <list: T list>
    "cons" operator appends a value to a list. it is right-associative 

NOTE: the synonym for [] is nil 

BUILT-IN LIST FUNCTIONS 

explode : string -> char list 
implode : char list -> string 
concat : string list -> string 

ML FILES 

to create a file that is reeadable by the ML interpreter, end it with the .sml extension or .ml extension 
then the built-in function to load a file into the ML interpreter is
    use : string -> unit 
where the input is the name of the file as a string. note that the contents are added to the ML stack environment.
comments in an ML file are surrounded b (* *)

Lecture 1-3: ML Function

the syntax to create a function in ML is 
    fun <identifier> <paramater(s):T1> = <expression:T2>
the name/type of this function will be 
    <identifier> : T1 -> T2 

Ex. write a function that inputs an integer and returns that integer plus 1.

    fun plusone x = x + 1;

Ex. write a function that inputs an integer and returns its square 

    fun square x = x*x;

Ex. write a function that inputs a real and returns its square 

    fun squarereal x:real = x*x

Ex. (In-Class) Write a function with name/type toUpper : char -> char 
    that inputs a lowercase character and returns its uppercase version (no error checking)

    fun toUpper x = chr(ord(x) - 32);

Ex. (In-Class) Write a function with name/type max3 : int * int * int -> int 
    that returns the maximum of three input integers. use the if-then-else operator only. 

    -fun max3(3, 9, 6);
    val it = 9 : int 

    fun max3 (a,b,c) = if <bool expression> then <expr1:T> else <expr2:T>
                       if a>b and a>c then a else if b>a and b>c then b else c 