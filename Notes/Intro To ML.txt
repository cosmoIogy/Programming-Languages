Lecture 1-1: Intro to ML

ML is a functional programming language, i.e., it evaluates expressions.

* every expression you put into the ML interpreter must end in a semicolon

the first response from the code 
    - 3+4;
is:
    val it = 7 : int

lets analyze:

val means value
it
    variable in the ML environment that contains the last expression evaluated 

:
    the ML symbol that associates values to types

int
    integer, the value type 

* ML is a strongly typed language, i.e., every expression in ML has a type 

BASIC/PRIMITIVE TYPES OF ML 

int
  the integer type. they are constructed by sequences of digits. you may start with ~ for negative values

real
  float/real decimal values. they are constructed by: 
   1) starts with optional ~
   2) a sequence of one or more digits
   3) (a) a decimal point and one or more digits
        (b) the letter E or e, an optional ~, and one or more digit

bool
   the boolean type. there are only two values: true, false

string
   they are constructed by surrounding characters with double quotes

char
   the character type. they are constructed by #"<character>"

unit
   there is only one value of this type: () 

--

Continue Lecture 1-1

INTEGER OPERATORS
+, -, *, div, mod

REAL OPERATORS 
+, -, *, /

STRING OPERATOR 
^

NOTE: ML ignores whitespace and the up arrow retypes previous lines

COMPARISON OPERATORS 
=, <, >, <=, >=, <>

NOTE: These are overloaded on ints and real, except you cannot use = and <> on reals 

LOGICAL OPERATORS 

andalso, orelse, not 

NOTE: You can add parantheses with operators to force precedence, ex: (2+3)*5
Unitary operators have precedence over binary operators, generally. 

There are built in library functions for converting types (not casting)

COERCION FUNCTIONS 
ord: char -> int 
chr: int -> char 
real: int -> real
str: char -> string

IF-THEN-ELSE OPERATOR 
The form of the operator is:
    if <bool expression> then <expr1:T> else <expr2:T>
When the bool evaluates to true, the this expression exaluates to exp1, otherwise to exp2. both expressions must
be of the same type

Lecture 1-2: ML Variables, types, and Data Structures (List)

IDENITFIERS/VARIABLES IN ML 
Variables in ML are constructed by:
    1. Starts with an uppercase letter, lowercase letter, or '
    2. Followed by zero or more characters from step 1 including _
NOTE: We dont usually use ', ML will do this for a later concept 

VALUE DECLERATIONS
The code form to bind a value to a variable is:
    val <identifier> = <value>

TUPLES 
Tuples are constructed by:
    1. Start with (
    2. Sequence of values separted by ,
    3. End with ) 

NOTE: This is our first example of a non-primitive type. If the components of a tuple are of type T1, T2, ..., Tn,
then the type of the tuple is T1 * T2 * ... * Tn 

TUPLE OPERATOR 
#<digit><tuple>
    Returns the component in the tuple corresponding to the digit starting at 1

LISTS
Lists are constructed by:
    1. Starts with [
    2. Sequence of values of the SAME TYPE, seperated by commas 
    3. Ends with ]
If the values in a list are of Type T, then the list itself is of type T list (non-primitive)

The symbols: 'a, 'b, 'c, etc., are used by ML as placeholder types. They are pronounced as alpha, beta, gamma, etc

NOTE: List has higher precedence than *

LIST OPERATORS

hd <list>
    returns the first element of the list 

tl <list> 
    returns all but the head of the list (as a list)

<list1:T list>@<list2:T list>
    concantenates two list together 

NOTE: at the end of every ML list is an empty list

<value:T> :: <list: T list>
    "cons" operator appends a value to a list. it is right-associative 

NOTE: the synonym for [] is nil 

BUILT-IN LIST FUNCTIONS 

explode : string -> char list 
implode : char list -> string 
concat : string list -> string 

ML FILES 

to create a file that is reeadable by the ML interpreter, end it with the .sml extension or .ml extension 
then the built-in function to load a file into the ML interpreter is
    use : string -> unit 
where the input is the name of the file as a string. note that the contents are added to the ML stack environment.
comments in an ML file are surrounded b (* *)

Lecture 1-3: ML Function

the syntax to create a function in ML is 
    fun <identifier> <paramater(s):T1> = <expression:T2>
the name/type of this function will be 
    <identifier> : T1 -> T2 

Ex. write a function that inputs an integer and returns that integer plus 1.

    fun plusone x = x + 1;

Ex. write a function that inputs an integer and returns its square 

    fun square x = x*x;

Ex. write a function that inputs a real and returns its square 

    fun squarereal x:real = x*x

Ex. (In-Class) Write a function with name/type toUpper : char -> char 
    that inputs a lowercase character and returns its uppercase version (no error checking)

    fun toUpper x = chr(ord(x) - 32);

Ex. (In-Class) Write a function with name/type max3 : int * int * int -> int 
    that returns the maximum of three input integers. use the if-then-else operator only. 

    -fun max3(3, 9, 6);
    val it = 9 : int 

    fun max3 (a,b,c) = 
        if a>b then
            if a>c then a else c
        else
            if b>c then b else c;

In ML, global variables are frowned upon

val y = 4;
fun myfun a = y+a;
val y = 20;
myfun(3);
returns 7 because my fun is binded to the first value 

another way to construct a function is by declaring an anonymous functions/functions
defined on the fly/functions without a name. the syntax is:

    fn <parameter(s)> => expression;

    val addfour = fn x => x+4;

ex: write a function named apply that takes a function and value, then returns
that input function applied to the value 

fun apply (f, a) = f(a);
returns: val apply = fn : ('a -> 'b) * a' -> b'

ex: write a function called getFun that inputs an integer a and then returns the
function f(x) = a*x; 

fun getFun a = (fn x => a*x);
returns: val getFun = fn : int -> int -> int
                           input    output type
                           type 

ex. (in-class) write a function named past that inputs a string and then 
concantenates "ed" on the end. for example, 
    - past("suck");
    val it = "sucked" : string

fun past x = x ^ "ed";

ex. (in-class) write a function named jeremy : char -> string -> string 
that inputs a character c and then returns
the string function f(w) = wc (concantenates the character to the end of the string)
and test it. for example, 
    - val myfun = jeremy(#"z");
    val my fun = fn : string -> string
    - myfun("lor");
    val it = "lorz" : string

fun jeremy c = fn s => s^(str c);

Lecture 1-4: Recursion 

Loops are frowned upon! Thats a procedural style, not functional! 

Ex. Write our own length function named mylength. First, we do it badly:

fun mylength L = if L=[] then 0 else 1+mylength(tl(L));

NOTE: ''a means that you can only use equality types

A better way to define functions on lists in ML is to use pattern matching:

fun <identifier> <pattern1> = <exp1>
    <identifier> <pattern2> = <exp2>
    ..
    <identifier> <pattern-n> = <expn>

Allowed patterns are constants/literals or expressions with ::

fun mylength2 [] = 0
    | mylength2 (x::xs) = 1+mylength2(xs); 

This wildcard symbol in ML is _. It is used in place of a variable when it is not needed. The 
last example can be written more efficiently as:

fun mylength3 [] = 0
    | mylength3 (_::xs) = 1+mylength3(xs);

New construct: case 
Plays the role of "switch" from other language, but it is just another format to do
pattern matching. The syntax is

    case <expression> of <match> 

Then <match> will have the form 

    <patern1> => <exp1> | <pattern2> =>
    <exp2> | ... | <pattern-n> => <expn>

We can also write the last example as:

fun mylength4 L = case L of [] => 0 | (x::xs) => 1+mylength4(xs); 

Ex. write the factoiral function using recursion and pattern matching 

fun steve 0 = 1
    | steve n = n*steve(n-1);

Ex. write a function named listsum that inputs a list of integers and returns their sum. for example:
    - listsum [2,3,5,7];
    val it = 17 : int 

fun listsum [] = 0
    | listsum (x::xs) = x+sum(xs); 

Ex. Write a recursive function with pattern matching named pairlistsum that inputs an int * int list
and returns the sum of all values. For example,
    - pairlistsum [(2,3),(5,7)];
        val it = 17 : int 

fun pairlistsum [] = 0;
    | pairlistsum ((x,y)::xs) = x+y+pairlistsum(xs);

New Reserved Word: and 
Allows you to do more than one decleration at the same time 

Ex. Write mutually recursive functions with pattern matching named isOdd and isEven that inputs a 
non-neg integer and returns the correct bool value. For example,
    - isEven(4);
    val it = true : bool
    - isodd(4);
    val it = false : bool 

fun isEven 0 = true | isEven n = isOdd(n-1) and isOdd 0 = false | isOdd n = isEven(n-1);

Ex. Write a recursive ML function with pattern matching named linSearch that inputs a 2-tuple:
an int list and int. It will return the index position if the value is found. Assuming the indices
start at 1. If the value is not found, it should return -1 but instead, we will return list size plus 1
for now.

fun linSearch ([],_) = 1
    | linSearch (x::xs, n) = if x = n then 1 else 1+linSearch(xs,n);

Recall that last example: 

fun linSearch ([],_) = 1
    | linSearch (x::xs, n) = if x = n then 1 else 1+linSearch(xs,n);

To "save" information in a functional language, you can add an extra arguement in a function 
to hold data until its needed

ex. repeat the last example except it should return ~1 if the value is not found in the list. 
(We're going to create a back-end function to handle the recursion and a front-end function 
for the user to abstract what's happening under the hood)

BACK-END
fun helper ([],_,n) = ~n-1
|   helper (y::ys, x, n) = if x=y then 1 else 1+helper(ys,x,n);

FRONT END 
fun linSearch2(L,x) = helper(L,x,length(L));

New Syntax:
    let <decleration> in <expression> end 
This allows temperary declerations that can be used in <expression>. This syntax evaluates to <expression>.

The following code does the same as the previous example, except the helper function is temporary
and not accessible to the user 

fun linSearch3(L, x) = 
    let 
        fun helper ([],_,n) = ~n-1
        |   helper (y::ys, x, n) = if x=y then 1 
        else 1+helper(ys,x,n);
    in
        helper2(L,x,length(L))
    end;

NEW RESERVED WORD: as 
Allows us to use identifiers or parts of an identifier in expressions by doing additional bindings

Ex. write a recursive function using pattern matching with name and type 
    sortedMerge : int list * int list -> int list 
which inputs two sorted lists and returns a single combined sorted list of integers
For exmaple,
    - sortedMerge([2,3,5,7],[1,2,9])
    val it = [1,2,2,3,5,7,9] : int list 

fun sortedMerge ([],B) = B
|   sortedMerge (A,[]) = A
|   sortedMerge (A as x::xs, B as y::ys) = if x<y then x::sortedMerge(xs,B) else y::sortedMerge(A,ys);

MAP FUNCTION
The syntax for the built=in map function is 
    map <function> list 
that will return the list after the function has been applied to each element 

Ex. (in-class) use the map function to append the string "ed" at the end of every string on a list: 

    - map <??> ["box", "fix", "lock"];
    val it = ["boxed", "fixed", "locked"] : string list 

    map (fn x => x^"ed") ["box", "fix", "lock"]; 

REDUCE FUNCTIONS 
The built-in reduce function in ML are named foldl and foldr. Their syntax is 
<fold or foldr> <two-variable function> <initial value> <list> that takes the function and applies 
it continuously to every element of the list starting with the initial value  

fun myfun(cv,acc) = cv + acc;

foldl myfun 0 [2,3,5,7];

Ex. Use one of the reduce funtions to duplicate all elements in a list. For example, 
    - <foldl or foldr> <f> <IV> [2,3,5,7];
    val it = [2,2,3,3,5,5,7,7];

    fun myfun2(cv,acc) = cv :: cv :: acc;

Lecture 1-5: Advanced Types 

NEW TYPE: 'a option 
This new type has "two" values 
    NONE
    SOME x
where x is of type 'a

The option type allows "null" or "invalid" values that can represent no answer, no response, 
but can also maintain type consistency

Ex. Write a recursive function using pattern matching with name and type: 
    intopsum : int option list -> int 
that inputs a list of int options are returns their sum of all integers while ignoring any instances 
of NONE. For example 
    - intospum [SOME 2, NONE, NONE, SOME 3, NONE];
    val it = 5 : int

fun intospum [] = 0
|   intospum ((SOME x)::xs) = x+intopsum(xs)
|   intopsum (NONE::xs) = intopsum(xs);

Ex. Write a recursive function with pattern matching named countNones that inputs a list of options 
and returns the number of occurrences of NONE. For example, 
    - countNones [SOME 2, NONE, NONE, SOME 3, NONE];
    val it = 3 : int 

    fun countNones [] = 0
    |   countNones (NONE::xs) = 1+countNones xs
    |   countNones (SOME _::xs) = countNones xs; 


Ex. Write a recursive function with pattern matching named strip that inputs a list of options and 
removes all SOMEs and NONEs. For example, 
    - strip [SOME 2, NONE, NONE, SOME 3, NONE];
    val it = [2,3] : int list 
    - strip [NONE, SOME "a"];
    val it = ["a"] : string list 


Ex. (in-class) Write a recursive function with pattern matching named stropconcat that inputs a list 
of string options and returns the concatenation of all strings while ignoring any instances of NONE.
For example,
    -stropconcat [NONE, NONE, SOME "abc", NONE, SOME "de"];
    val it = 'abcde" : string 

    fun stropconcat [] = ""
    |   stropconcat (NONE::xs) = stropconcat(xs)
    |   stronconcat ((SOME x)::xs) = x^strconcat(xs);

CUSTOM TYPES 
The syntax to create a custom data type is 
    datatype <typename> = <val1> | <val2> | ...
where each value can be a literal or a constructor of the form 
    <constructor name> of <type> 

    datatype color = blue | red | yellow;

Recall from java, create a new class for linked list nodes 

public class Node() {
    private int data;
    private Node next;
}

In ML, we shall create our own linked list type to create nodes! 

datatype linkedList = empty | node of int * linkedList;

node (3, node(5,empty)); <- a linked list with 3 pointing to 5

Now lets code those Java methods for linked lists!
Ex. write a recursive function with pattern matching with name and type
    isEmpty : linkedList -> bool 
that returns true if and only if it receives an empty linked list 

fun isEmpty empty = true
|   isEmpty (node(_)) = false; 

Ex. (in-class) write a recursive function with pattern matching with name and type 
        getSize : linkedList -> int
    that returns the number of nodes

fun getSize empty = 0
|   getSize node(_,y) = 1+getSize(y);

Exam 1:
Sections 1.1, 1.2, 1.3, 1.4, 1.5

--
Jan 05

Lecture 1-6: ML Input and Output 

We will learn how to read and write files so that ML can communicate with the outside world 
Warning: Sometimes using VSCode extensions with SML can produce unexpected results. Make sure 
you test anything you submit on a regular terminal

There is a built in function to load .sml files into the ML intepreter 
    use : string -> unit 

This inputs a filename as a string, and returns nothing. The side effect is that the code in the file 
is loaded into the ML environment/stack 

There is a built in function to write strings to the terminal 

    print : string -> unit 

print("Hello world");

Ex. Write an ML function with name and type 
    pchar : char -> unit 
that inputs a character, prints the character to the terminal, and returns unit 

fun pchar c = print(str(c)^"\n");
pchar(#"D");

STRUCTURES 
A structure is a built-in "library" that contains predefined functions and values that you can 
import into the ML environment. For example, two structures are 
    Int 
    Bool
As a subexample, both these stuctures contained the function toString 

Int.toString;
Bool.toString;
Int.toString(77);

The reserved word to load ALL of a structures contents into the ML environment is open:
    open <structure name>

open Int;

You can have a series of expressions seperated by semicolons. If you do, ML will evaluate to the last
expression 

3; "56"; true;

Ex. Write a recursive Ml function using pattern matching that inputs a list of bools, prints them 
to the terminal, and returns unit. For example:
    - pbools [true,false,false];
    true
    false
    false
    val it = () : unit 

fun pbools [] = () 
|   pbools (x::xs) = (
    print(Bool.toString(x)^"\n");
    pbools(xs)
);

NOTE: You can now use this technique for debugging. You can add extra print statements as needed inside code,
just remember that the last expression must return the correct type.

FILE READING

NEW STRUCTURE : TextIO
    Library contains functions for reading from files 

NEW TYPE: instream
    Represented by a token we cant see, which is used for accessing files to read 

NEW FUNCTIONS in TextIO 

    TextIO.openIn : string -> instream
        Takes a filename as a string and returns a reference to a file for reading 

    TextIO.closeIN : instream -> unit 
        Closes a file (deallocate) that was used for reading and returns unit 

    TextIO.endOfStream : instream -> bool 
        Checks whether we are at the end of the files and returns true or false 

    TextIO.inputN : instream * int -> string 
        Reads the next int number of characters from the files and returns them as a string. 
        The file is unchanged and the characters are "consumed" from the instream 

val infile = TextIO.openIn("jason.txt");
TextIO.inputN(infile, 3);